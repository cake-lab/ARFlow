// Vendored from https://github.com/Picovoice/unity-voice-processor/blob/main/Assets/UnityVoiceProcessor/VoiceProcessor.cs. We have made modifications to the original code.
//
// Copyright 2021-2023 Picovoice Inc.
//
// You may not use this file except in compliance with the license. A copy of the license is located in the "LICENSE"
// file accompanying this source.
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

namespace CakeLab.ARFlow.Utilities
{
    /// <summary>
    /// Listener type that can be added to VoiceProcessor with `.addFrameListener()`. Captures audio
    /// frames that are generated by the recording thread.
    /// </summary>
    public delegate void VoiceProcessorFrameListener(float[] frame);

    /// <summary>
    /// Class that records audio and delivers frames for real-time audio processing
    /// </summary>
    public class VoiceProcessor : MonoBehaviour
    {
        private AudioSource m_AudioSource;
        private event Action OnRestartRecording;
        private event VoiceProcessorFrameListener OnFrame;

        /// <summary>
        /// Available audio recording devices.
        /// </summary>
        public List<string> Devices { get; private set; }

        /// <summary>
        /// Index of selected audio recording device.
        /// </summary>
        public int CurrentDeviceIndex { get; private set; }

        /// <summary>
        /// Name of selected audio recording device.
        /// </summary>
        public string CurrentDeviceName
        {
            get
            {
                if (CurrentDeviceIndex < 0 || CurrentDeviceIndex >= Microphone.devices.Length)
                    return string.Empty;
                return Devices[CurrentDeviceIndex];
            }
        }

        /// <summary>
        /// Sample rate of recorded audio
        /// </summary>
        public int SampleRate { get; private set; }

        /// <summary>
        /// Size of audio frames that are delivered
        /// </summary>
        public int FrameLength { get; private set; }

        /// <summary>
        /// The number of registered `VoiceProcessorFrameListeners`.
        /// </summary>
        public int NumFrameListeners
        {
            get
            {
                if (OnFrame == null)
                {
                    return 0;
                }
                return OnFrame.GetInvocationList().Length;
            }
        }

        /// <summary>
        /// Mixer to manage microphone audio.
        /// </summary>
        private readonly AudioMixerGroup m_VoiceProcessorMixer;

        /// <summary>
        /// Indicates whether microphone is capturing or not.
        /// </summary>
        public bool IsRecording
        {
            get { return m_AudioSource.clip != null && Microphone.IsRecording(CurrentDeviceName); }
        }

        /// <summary>
        /// Singleton instance of the VoiceProcessor.
        /// </summary>
        static VoiceProcessor m_Instance;

        public static VoiceProcessor Instance
        {
            get
            {
                if (m_Instance == null)
                    FindFirstObjectByType<VoiceProcessor>();
                if (m_Instance == null)
                {
                    m_Instance = new GameObject(
                        "CakeLab.ARFlow.DataBuffers.VoiceProcessor"
                    ).AddComponent<VoiceProcessor>();
                    DontDestroyOnLoad(m_Instance.gameObject);
                }
                return m_Instance;
            }
        }

        /// <summary>
        /// Add a frame listener that will receive audio frames generated by the VoiceProcessor.
        /// </summary>
        /// <param name="listener">`VoiceProcessorFrameListener` for processing frames of audio.</param>
        public void AddFrameListener(VoiceProcessorFrameListener listener)
        {
            OnFrame += listener;
        }

        /// <summary>
        /// Add multiple frame listeners that will receive audio frames generated by the VoiceProcessor.
        /// </summary>
        /// <param name="listeners">`VoiceProcessorFrameListeners` for processing frames of audio.</param>
        public void AddFrameListeners(VoiceProcessorFrameListener[] listeners)
        {
            foreach (var listener in listeners)
            {
                OnFrame += listener;
            }
        }

        /// <summary>
        /// Remove a frame listener from the VoiceProcessor. It will no longer receive audio frames.
        /// </summary>
        /// <param name="listener">`VoiceProcessorFrameListener` that you would like to remove.</param>
        public void RemoveFrameListener(VoiceProcessorFrameListener listener)
        {
            OnFrame -= listener;
        }

        /// <summary>
        /// Remove frame listeners from the VoiceProcessor. They will no longer receive audio frames.
        /// </summary>
        /// <param name="listeners">`VoiceProcessorFrameListeners` that you would like to remove.</param>
        public void RemoveFrameListeners(VoiceProcessorFrameListener[] listeners)
        {
            foreach (var listener in listeners)
            {
                OnFrame -= listener;
            }
        }

        /// <summary>
        /// Clears all currently registered frame listeners.
        /// </summary>
        public void ClearFrameListeners()
        {
            OnFrame = null;
        }

        /// <summary>
        /// Starts audio recording with the specified audio properties.
        /// </summary>
        /// <param name="frameLength">The length of each audio frame, in number of samples.</param>
        /// <param name="sampleRate">The sample rate to record audio at, in Hz.</param>
        public void StartRecording(int frameLength, int sampleRate)
        {
            if (IsRecording)
            {
                // if sample rate or frame size have changed, restart recording
                if (sampleRate != SampleRate || frameLength != FrameLength)
                {
                    throw new VoiceProcessorArgumentException(
                        String.Format(
                            "VoiceProcessor StartRecording() was called with frame length "
                                + "%d and sample rate %d while already recording with "
                                + "frame length %d and sample rate %d",
                            frameLength,
                            sampleRate,
                            FrameLength,
                            SampleRate
                        )
                    );
                }
                return;
            }

            SampleRate = sampleRate;
            FrameLength = frameLength;

            m_AudioSource.clip = Microphone.Start(CurrentDeviceName, true, 1, sampleRate);
            m_AudioSource.outputAudioMixerGroup = m_VoiceProcessorMixer;

            StartCoroutine(RecordData());
        }

        /// <summary>
        /// Stops audio recording and releases audio resources.
        /// </summary>
        public void StopRecording()
        {
            if (!IsRecording)
                return;

            Microphone.End(CurrentDeviceName);
            Destroy(m_AudioSource.clip);
            m_AudioSource.clip = null;

            StopCoroutine(RecordData());
        }

        /// <summary>
        /// Basic Voice Processor setup on init.
        /// </summary>
        public void Awake()
        {
            if (m_AudioSource == null)
                GetComponent<AudioSource>();
            if (m_AudioSource == null)
            {
                m_AudioSource = gameObject.AddComponent<AudioSource>();
            }

            UpdateDevices();
        }

        /// <summary>
        /// Updates list of available audio devices.
        /// </summary>
        public void UpdateDevices()
        {
            Devices = new List<string>();
            foreach (var device in Microphone.devices)
            {
                Devices.Add(device);
            }

            if (Devices == null || Devices.Count == 0)
            {
                CurrentDeviceIndex = -1;
                throw new VoiceProcessorStateException(
                    "There is no valid recording device connected"
                );
            }

            CurrentDeviceIndex = 0;
        }

        /// <summary>
        /// Change audio recording device.
        /// Unlike the original package code, WE ARE REMODIFYING THE EVENT HANDLER TO RECEIVE FLOAT.
        /// </summary>
        /// <param name="deviceIndex">Index of the new audio capture device.</param>
        public void ChangeDevice(int deviceIndex)
        {
            if (deviceIndex < 0 || deviceIndex >= Devices.Count)
            {
                throw new VoiceProcessorArgumentException(
                    string.Format(
                        "Specified device index {0} is not a valid recording device",
                        deviceIndex
                    )
                );
            }

            if (IsRecording)
            {
                // one time event to restart recording with the new device
                // the moment the last session has completed
                OnRestartRecording += () =>
                {
                    CurrentDeviceIndex = deviceIndex;
                    StartRecording(FrameLength, SampleRate);
                    OnRestartRecording = null;
                };
                StopRecording();
            }
            else
            {
                CurrentDeviceIndex = deviceIndex;
            }
        }

        /// <summary>
        /// Loop for buffering incoming audio data and delivering frames.
        /// </summary>
        private IEnumerator RecordData()
        {
            float[] sampleFrame = new float[FrameLength];
            int startReadPos = 0;

            while (IsRecording)
            {
                int curClipPos = Microphone.GetPosition(CurrentDeviceName);
                if (curClipPos < startReadPos)
                    curClipPos += m_AudioSource.clip.samples;

                int samplesAvailable = curClipPos - startReadPos;
                if (samplesAvailable < FrameLength)
                {
                    yield return null;
                    continue;
                }

                int endReadPos = startReadPos + FrameLength;
                if (endReadPos > m_AudioSource.clip.samples)
                {
                    // fragmented read (wraps around to beginning of clip)
                    // read bit at end of clip
                    int numSamplesClipEnd = m_AudioSource.clip.samples - startReadPos;
                    float[] endClipSamples = new float[numSamplesClipEnd];
                    m_AudioSource.clip.GetData(endClipSamples, startReadPos);

                    // read bit at start of clip
                    int numSamplesClipStart = endReadPos - m_AudioSource.clip.samples;
                    float[] startClipSamples = new float[numSamplesClipStart];
                    m_AudioSource.clip.GetData(startClipSamples, 0);

                    // combine to form full frame
                    Buffer.BlockCopy(endClipSamples, 0, sampleFrame, 0, numSamplesClipEnd);
                    Buffer.BlockCopy(
                        startClipSamples,
                        0,
                        sampleFrame,
                        numSamplesClipEnd,
                        numSamplesClipStart
                    );
                }
                else
                {
                    m_AudioSource.clip.GetData(sampleFrame, startReadPos);
                }

                startReadPos = endReadPos % m_AudioSource.clip.samples;

                // converts to 16-bit int samples
                //short[] frame = new short[sampleFrame.Length];
                //for (int i = 0; i < FrameLength; i++)
                //{
                //    frame[i] = (short)Math.Floor(sampleFrame[i] * short.MaxValue);
                //}

                OnFrame?.Invoke(sampleFrame);
            }

            OnRestartRecording?.Invoke();
        }
    }
}
